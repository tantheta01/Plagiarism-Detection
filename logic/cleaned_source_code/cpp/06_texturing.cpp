CSX75 Tutorial 6 Texturing a CubeModified from An Introduction to OpenGL Programming,Ed Angel and Dave Shreiner, SIGGRAPH 2013Written by Aditya Prakash, 2015//////////// LOAD TEXTURES///////// DEBUG#include "06_texturing.hpp"#include "texture.hpp"GLuint shaderProgram;GLuint vbo[2], vao[2];GLuint tex;glm::mat4 rotation_matrix;glm::mat4 projection_matrix;glm::mat4 c_rotation_matrix;glm::mat4 lookat_matrix;glm::mat4 model_matrix;glm::mat4 view_matrix;glm::mat4 modelview_matrix;glm::mat3 normal_matrix;GLuint uModelViewMatrix;GLuint viewMatrix;GLuint normalMatrix;//-----------------------------------------------------------------//6 faces, 2 triangles/face, 3 vertices/triangleconst int  36;glm::vec4 texCoordinates[8];//Eight vertices in homogenous coordinatesglm::vec4 positions[8] = {glm::vec4(-0.5, -0.5, 0.5, 1.0),glm::vec4(-0.5, 0.5, 0.5, 1.0),glm::vec4(0.5, 0.5, 0.5, 1.0),glm::vec4(0.5, -0.5, 0.5, 1.0),glm::vec4(-0.5, -0.5, -0.5, 1.0),glm::vec4(-0.5, 0.5, -0.5, 1.0),glm::vec4(0.5, 0.5, -0.5, 1.0),glm::vec4(0.5, -0.5, -0.5, 1.0)glm::vec4 normals[8] = {glm::vec4(-0.5, -0.5, 0.5, 1.0),glm::vec4(-0.5, 0.5, 0.5, 1.0),glm::vec4(0.5, 0.5, 0.5, 1.0),glm::vec4(0.5, -0.5, 0.5, 1.0),glm::vec4(-0.5, -0.5, -0.5, 1.0),glm::vec4(-0.5, 0.5, -0.5, 1.0),glm::vec4(0.5, 0.5, -0.5, 1.0),glm::vec4(0.5, -0.5, -0.5, 1.0)//RGBA colorsglm::vec4 colors[8] = {glm::vec4(0.0, 0.0, 0.0, 1.0),glm::vec4(1.0, 0.0, 0.0, 1.0),glm::vec4(1.0, 1.0, 0.0, 1.0),glm::vec4(0.0, 1.0, 0.0, 1.0),glm::vec4(0.0, 0.0, 1.0, 1.0),glm::vec4(1.0, 0.0, 1.0, 1.0),glm::vec4(1.0, 1.0, 1.0, 1.0),glm::vec4(0.0, 1.0, 1.0, 1.0)glm::vec2 t_coords[4] = {glm::vec2( 0.0, 0.0),glm::vec2( 0.0, 1.0),glm::vec2( 1.0, 0.0),glm::vec2( 1.0, 1.0)glm::vec4 color(0.6, 0.6, 0.6, 1.0);glm::vec4 black(0.1, 0.1, 0.1, 1.0);glm::vec4 white(0.2, 0.7, 0.7, 1.0);glm::vec4 red(1.0, 0.2, 0.2, 1.0);glm::vec4 yellow(0.8, 0.8, 0.0, 1.0);glm::vec4 green(0.2, 0.7, 0.2, 1.0);glm::vec4 blue(0.2, 0.2, 0.7, 1.0);int 0;glm::vec4 v_positions[num_vertices];glm::vec4 v_colors[num_vertices];glm::vec4 v_normals[num_vertices];glm::vec2 tex_coords[num_vertices];// quad generates two triangles for each face and assigns colors to the verticesvoid quad(int a, int b, int c, int d, glm::vec4 color)v_colors[tri_idx] = color; v_positions[tri_idx] = positions[a];v_normals[tri_idx] = normals[a];tex_coords[tri_idx] = t_coords[1];tri_idx++;v_colors[tri_idx] = color; v_positions[tri_idx] = positions[b];v_normals[tri_idx] = normals[b];tex_coords[tri_idx] = t_coords[0];tri_idx++;v_colors[tri_idx] = color; v_positions[tri_idx] = positions[c];v_normals[tri_idx] = normals[c];tex_coords[tri_idx] = t_coords[2];tri_idx++;v_colors[tri_idx] = color; v_positions[tri_idx] = positions[a];v_normals[tri_idx] = normals[a];tex_coords[tri_idx] = t_coords[1];tri_idx++;v_colors[tri_idx] = color; v_positions[tri_idx] = positions[c];v_normals[tri_idx] = normals[c];tex_coords[tri_idx] = t_coords[2];tri_idx++;v_colors[tri_idx] = color; v_positions[tri_idx] = positions[d];v_normals[tri_idx] = normals[d];tex_coords[tri_idx] = t_coords[3];tri_idx++;// generate 12 triangles: 36 vertices and 36 colorsvoid colorcube(void)quad( 1, 0, 3, 2, red);quad( 2, 3, 7, 6, green);quad( 3, 0, 4, 7, white);quad( 6, 5, 1, 2, yellow);quad( 4, 5, 6, 7, black);quad( 5, 4, 0, 1, blue);//-----------------------------------------------------------------void initBuffersGL(void)// Load shaders and use the resulting shader programstd::string vertex_shader_file("06_vshader.glsl");std::string fragment_shader_file("06_fshader.glsl");std::vector<GLuint> shaderList;shaderList.push_back(csX75::LoadShaderGL(GL_VERTEX_SHADER, vertex_shader_file));shaderList.push_back(csX75::LoadShaderGL(GL_FRAGMENT_SHADER, fragment_shader_file));csX75::CreateProgramGL(shaderList);glUseProgram( shaderProgram );// getting the attributes from the shader programGLuint  glGetAttribLocation( shaderProgram, "vPosition" );GLuint  glGetAttribLocation( shaderProgram, "vColor" );GLuint  glGetAttribLocation( shaderProgram, "vNormal" );GLuint  glGetAttribLocation( shaderProgram, "texCoord" );glGetUniformLocation( shaderProgram, "uModelViewMatrix");glGetUniformLocation( shaderProgram, "normalMatrix");glGetUniformLocation( shaderProgram, "viewMatrix");// Load TexturesGLuint LoadTexture("images/all1.bmp",256,256);glBindTexture(GL_TEXTURE_2D, tex);//Ask GL for two Vertex Attribute Objects (vao) , one for the sphere and one for the wireframeglGenVertexArrays (2, vao);//Ask GL for two Vertex Buffer Object (vbo)glGenBuffers (2, vbo);//Set 0 as the current array to be used by binding itglBindVertexArray (vao[0]);//Set 0 as the current buffer to be used by binding itglBindBuffer (GL_ARRAY_BUFFER, vbo[0]);colorcube();//Copy the points into the current bufferglBufferData (GL_ARRAY_BUFFER, sizeof (v_positions) + sizeof(tex_coords) + sizeof(v_normals), NULL, GL_STATIC_DRAW);glBufferSubData( GL_ARRAY_BUFFER, 0, sizeof(v_positions), v_positions );glBufferSubData( GL_ARRAY_BUFFER, sizeof(v_positions), sizeof(tex_coords), tex_coords);glBufferSubData( GL_ARRAY_BUFFER, sizeof(tex_coords)+sizeof(v_positions), sizeof(v_normals), v_normals );// set up vertex array//PositionglEnableVertexAttribArray( vPosition );glVertexAttribPointer( vPosition, 4, GL_FLOAT, GL_FALSE, 0, BUFFER_OFFSET(0) );//TexturesglEnableVertexAttribArray( texCoord );glVertexAttribPointer( texCoord, 2, GL_FLOAT, GL_FALSE, 0, BUFFER_OFFSET(sizeof(v_positions)) );//NormalglEnableVertexAttribArray( vNormal );glVertexAttribPointer( vNormal, 3, GL_FLOAT, GL_FALSE, 0, BUFFER_OFFSET(sizeof(v_positions)+sizeof(tex_coords)) );void renderGL(void)glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);glm::rotate(glm::mat4(1.0f), glm::radians(xrot), glm::vec3(1.0f,0.0f,0.0f));glm::rotate(rotation_matrix, glm::radians(yrot), glm::vec3(0.0f,1.0f,0.0f));glm::rotate(rotation_matrix, glm::radians(zrot), glm::vec3(0.0f,0.0f,1.0f));rotation_matrix;//Creating the lookat and the up vectors for the cameraglm::rotate(glm::mat4(1.0f), glm::radians(c_xrot), glm::vec3(1.0f,0.0f,0.0f));glm::rotate(c_rotation_matrix, glm::radians(c_yrot), glm::vec3(0.0f,1.0f,0.0f));glm::rotate(c_rotation_matrix, glm::radians(c_zrot), glm::vec3(0.0f,0.0f,1.0f));glm::vec4  glm::vec4(c_xpos,c_ypos,c_zpos, 1.0)*c_rotation_matrix;glm::vec4  glm::vec4(c_up_x,c_up_y,c_up_z, 1.0)*c_rotation_matrix;//Creating the lookat matrixglm::lookAt(glm::vec3(c_pos),glm::vec3(0.0),glm::vec3(c_up));//creating the projection matrixglm::frustum(-1.0, 1.0, -1.0, 1.0, 1.0, 5.0);projection_matrix*lookat_matrix;glUniformMatrix4fv(viewMatrix, 1, GL_FALSE, glm::value_ptr(view_matrix));// Draw the sphereview_matrix*model_matrix;glUniformMatrix4fv(uModelViewMatrix, 1, GL_FALSE, glm::value_ptr(modelview_matrix));glm::transpose (glm::inverse(glm::mat3(modelview_matrix)));glUniformMatrix3fv(normalMatrix, 1, GL_FALSE, glm::value_ptr(normal_matrix));//  glBindTexture(GL_TEXTURE_2D, tex);glBindVertexArray (vao[0]);glDrawArrays(GL_TRIANGLES, 0, num_vertices);int main(int argc, char** argv)//! The pointer to the GLFW windowGLFWwindow* window;//! Setting up the GLFW Error callbackglfwSetErrorCallback(csX75::error_callback);//! Initialize GLFWif (!glfwInit())return -1;//We want OpenGL 4.0glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);//This is for MacOSX - can be omitted otherwiseglfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);//We don't want the old OpenGLglfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);//! Create a windowed mode window and its OpenGL contextglfwCreateWindow(512, 512, "CS475/CS675 Tutorial 6: Texturing a cube", NULL, NULL);if (!window)glfwTerminate();return -1;//! Make the window's context currentglfwMakeContextCurrent(window);//Initialize GLEW//Turn this on to get Shader based OpenGLGL_TRUE;GLenum  glewInit();if (GLEW_OK != err)//Problem: glewInit failed, something is seriously wrong.std::cerr<<"GLEW Init Failed : %s"<<std::endl;//Keyboard CallbackglfwSetKeyCallback(window, csX75::key_callback);//Framebuffer resize callbackglfwSetFramebufferSizeCallback(window, csX75::framebuffer_size_callback);// Ensure we can capture the escape key being pressed belowglfwSetInputMode(window, GLFW_STICKY_KEYS, GL_TRUE);//Initialize GL statecsX75::initGL();initBuffersGL();// Loop until the user closes the windowwhile (glfwWindowShouldClose(window) == 0)// Render hererenderGL();// Swap front and back buffersglfwSwapBuffers(window);// Poll for and process eventsglfwPollEvents();glfwTerminate();return 0;//-------------------------------------------------------------------------