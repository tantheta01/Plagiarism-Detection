#include<bits/stdc++.h>class quad_nodepublic:bool value;int size, begx, begy;quad_node *up;quad_node *down;quad_node *left;quad_node *right;quad_node(int s, int bx, int by){this-> s;this-> bx;this-> by;NULL;NULL;NULL;NULL;~quad_node(){if (up != NULL)delete up;delete down;delete left;delete right;quad_node(quad_node *nhead){this-> nhead->value;int bx, by;//  ;--//  ;this-> nhead->size;this-> nhead->begx;this-> nhead->begy;if(up!=NULL){new quad_node(nhead->up);new quad_node(nhead->down);new quad_node(nhead->left);new quad_node(nhead->right);void set(int x1, int y1, int x2, int y2, bool val){int  this->begx + (1<<this->size);int  this->begy + (1<<this->size);if(x1 <= this->begx && x2 >= endx-1 &&  y1 <= this->begy && y2 >= endy-1){this-> val;delete up;delete down;delete left;delete right;else if(this->begx > x2 || endx <= x1 || this->begy > y2 || endy <= y1){return;elsequad_node * new quad_node(this->size-1, this->begx, this->begy);quad_node * new quad_node(this->size-1, this->begx + (1<<(this->size-1)), this->begy);quad_node * new quad_node(this->size-1, this->begx, this->begy + (1<<(this->size-1)));quad_node * new quad_node(this->size-1, this->begx + (1<<(this->size-1)), this->begy + (1<<(this->size-1)));u1->set(x1, y1, x2, y2, val);d1->set(x1, y1, x2, y2, val);l1->set(x1, y1, x2, y2, val);r1->set(x1, y1, x2, y2, val);u1;d1;r1;l1;bool get(int x1, int y1){if(this->= NULL){return this->value;else{if(x1 < this->begx + (1<<(size-1)) && y1 < this->begy + (1<<(this->size-1)))return up->get(x1, y1);else if(x1 < this->begx + (1<<(size-1))){return left->get(x1, y1);else if(y1 < this->begy + (1<<(this->size-1))){return down->get(x1, y1);else{return right->get(x1, y1);void overlap(quad_node *Q){if(this->= NULL && Q->= NULL){this-> this->value | Q->value;else if(this->= NULL){if(this->=0){quad_node * new quad_node(this->size-1, this->begx, this->begy);quad_node * new quad_node(this->size-1, this->begx + (1<<(this->size-1)), this->begy);quad_node * new quad_node(this->size-1, this->begx, this->begy + (1<<(this->size-1)));quad_node * new quad_node(this->size-1, this->begx + (1<<(this->size-1)), this->begy + (1<<(this->size-1)));u1->overlap(Q->up);d1->overlap(Q->down);l1->overlap(Q->left);r1->overlap(Q->right);this-> u1, this-> d1, this-> r1, this-> l1;else return;else if(Q->= NULL){if(Q->= 1){this->1;delete this->up;delete this->down;delete this->left;delete this->right;return;else{return;else{this->up->overlap(Q->up);this->down->overlap(Q->down);this->left->overlap(Q->left);this->right->overlap(Q->right);void intersection(quad_node *Q)if(this->= NULL && Q->= NULL){this-> this->value & Q->value;return;else if(this->= NULL){if(this->=1){quad_node * new quad_node(this->size-1, this->begx, this->begy);quad_node * new quad_node(this->size-1, this->begx + (1<<(this->size-1)), this->begy);quad_node * new quad_node(this->size-1, this->begx, this->begy + (1<<(this->size-1)));quad_node * new quad_node(this->size-1, this->begx + (1<<(this->size-1)), this->begy + (1<<(this->size-1)));u1->overlap(Q->up);d1->overlap(Q->down);l1->overlap(Q->left);r1->overlap(Q->right);this-> u1, this-> d1, this-> r1, this-> l1;else return;else if(Q->= NULL){if(Q->= 0){this->0;delete this->up;delete this->down;delete this->left;delete this->right;return;else{return;else{this->up->overlap(Q->up);this->down->overlap(Q->down);this->left->overlap(Q->left);this->right->overlap(Q->right);void complement(){if (this->= NULL)this-> this->value^1;else{this->down->complement();this->up->complement();this->left->complement();this->right->complement();void incsize(int inc){this-> this->size+inc;this->up->incsize(inc);this->down->incsize(inc);this->left->incsize(inc);this->right->incsize(inc);int decsize(int dec){if(size > dec){if(this->= NULL){this->size -= dec;return;else{this->up->decsize(dec);this->down->decsize(dec);this->left->decsize(dec);this->right->decsize(dec);if (up->= down->value && up->= left->value && up->= right->value)this-> this->up->value;delete up;delete down;delete left;delete right;this->size -= dec;return;else if(= dec){if(this->= NULL){else{long long  up->decsize(dec) + down->decsize(dec) + left->decsize(dec) + right->decsize(dec);if(ans < (1<<(size-1))){this->0;delete up;delete down;delete left;delete right;else{this->1;delete up;delete down;delete left;delete right;else{if(this->=NULL){return (1<<this->size);else{return up->decsize(dec) + down->decsize(dec) + right->decsize(dec) + left->decsize(dec);quad_node *resize(int x1, int y1, int m){if(this->= NULL){class quad_treequad_node *head;int size;public:quad_tree(int n){new quad_node(n, 0, 0);int getsize()return this->size;quad_node *getroot(){return head;quad_tree(const quad_tree &Q){delete head;this-> Q.getsize();quad_tree * Q.getroot();void set(int x1, int y1, int x2, int y2, int b){~quad_tree();