#include "gl_framework.hpp"#include "shader_util.hpp"float points[] = {0.0f,  0.5f,  0.0f,0.5f, -0.5f,  0.0f,-0.5f, -0.5f,  0.0fGLuint shaderProgram;GLuint vbo, vao;void initShadersGL(void)std::string vertex_shader_file("simple_vs.glsl");std::string fragment_shader_file("simple_fs.glsl");std::vector<GLuint> shaderList;shaderList.push_back(csX75::LoadShaderGL(GL_VERTEX_SHADER, vertex_shader_file));shaderList.push_back(csX75::LoadShaderGL(GL_FRAGMENT_SHADER, fragment_shader_file));csX75::CreateProgramGL(shaderList);void initVertexBufferGL(void)//Ask GL for a Vertex Buffer Object (vbo)glGenBuffers (1, &vbo);//Set it as the current buffer to be used by binding itglBindBuffer (GL_ARRAY_BUFFER, vbo);//Copy the points into the current buffer - 9 float values, start pointer and static dataglBufferData (GL_ARRAY_BUFFER, 9 * sizeof (float), points, GL_STATIC_DRAW);//Ask GL for a Vertex Attribute Object (vao)glGenVertexArrays (1, &vao);//Set it as the current array to be used by binding itglBindVertexArray (vao);//Enable the vertex attributeglEnableVertexAttribArray (0);//This the layout of our first vertex buffer//"0" means define the layout for attribute number 0. "3" means that the variables are vec3 made from every 3 floatsglVertexAttribPointer (0, 3, GL_FLOAT, GL_FALSE, 0, NULL);void renderGL(void)glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);glUseProgram(shaderProgram);glBindVertexArray (vao);// Draw points 0-3 from the currently bound VAO with current in-use shaderglDrawArrays(GL_TRIANGLES, 0, 3);int main(int argc, char** argv)//! The pointer to the GLFW windowGLFWwindow* window;//! Setting up the GLFW Error callbackglfwSetErrorCallback(csX75::error_callback);//! Initialize GLFWif (!glfwInit())return -1;//We want OpenGL 4.0glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);//This is for MacOSX - can be omitted otherwiseglfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);//We don't want the old OpenGLglfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);//! Create a windowed mode window and its OpenGL contextglfwCreateWindow(640, 480, "CS475/CS675 OpenGL Framework", NULL, NULL);if (!window)glfwTerminate();return -1;//! Make the window's context currentglfwMakeContextCurrent(window);//Initialize GLEW//Turn this on to get Shader based OpenGLGL_TRUE;GLenum  glewInit();if (GLEW_OK != err)//Problem: glewInit failed, something is seriously wrong.std::cerr<<"GLEW Init Failed : %s"<<std::endl;//Print and see what context got enabledstd::cout<<"Vendor: "<<glGetString (GL_VENDOR)<<std::endl;std::cout<<"Renderer: "<<glGetString (GL_RENDERER)<<std::endl;std::cout<<"Version: "<<glGetString (GL_VERSION)<<std::endl;std::cout<<"GLSL Version: "<<glGetString (GL_SHADING_LANGUAGE_VERSION)<<std::endl;//Keyboard CallbackglfwSetKeyCallback(window, csX75::key_callback);//Framebuffer resize callbackglfwSetFramebufferSizeCallback(window, csX75::framebuffer_size_callback);// Ensure we can capture the escape key being pressed belowglfwSetInputMode(window, GLFW_STICKY_KEYS, GL_TRUE);//Initialize GL statecsX75::initGL();initShadersGL();initVertexBufferGL();// Loop until the user closes the windowwhile (glfwWindowShouldClose(window) == 0)// Render hererenderGL();// Swap front and back buffersglfwSwapBuffers(window);// Poll for and process eventsglfwPollEvents();glfwTerminate();return 0;