/// @ref core/// @file glm/core/dummy.cpp////// GLM is a header only library. There is nothing to compile./// dummy.cpp exist only a wordaround for CMake file.#define GLM_MESSAGES#include <glm/glm.hpp>#include <glm/ext.hpp>#include <limits>struct materialglm::vec4 emission; // Ecmglm::vec4 ambient; // Acmglm::vec4 diffuse; // Dcmglm::vec4 specular; // Scmfloat shininess; // Srmstruct lightglm::vec4 ambient; // Acliglm::vec4 diffuse; // Dcliglm::vec4 specular; // Scliglm::vec4 position; // Ppliglm::vec4 halfVector; // Derived: Higlm::vec3 spotDirection; // Sdlifloat spotExponent; // Srlifloat spotCutoff; // Crli// (range: [0.0,90.0], 180.0)float spotCosCutoff; // Derived: cos(Crli)// (range: [1.0,0.0],-1.0)float constantAttenuation; // K0float linearAttenuation; // K1float quadraticAttenuation;// K2// Sample 1#include <glm/vec3.hpp>// glm::vec3#include <glm/geometric.hpp>// glm::cross, glm::normalizeglm::vec3 computeNormalglm::vec3 const& a,glm::vec3 const& b,glm::vec3 const& creturn glm::normalize(glm::cross(c - a, b - a));typedef unsigned int GLuint;#define GL_FALSE 0void glUniformMatrix4fv(GLuint, int, int, float*){}// Sample 2#include <glm/vec3.hpp> // glm::vec3#include <glm/vec4.hpp> // glm::vec4, glm::ivec4#include <glm/mat4x4.hpp> // glm::mat4#include <glm/gtc/matrix_transform.hpp> // glm::translate, glm::rotate, glm::scale, glm::perspective#include <glm/gtc/type_ptr.hpp> // glm::value_ptrvoid func(GLuint LocationMVP, float Translate, glm::vec2 const& Rotate)glm::mat4  glm::perspective(45.0f, 4.0f / 3.0f, 0.1f, 100.f);glm::mat4  glm::translate(glm::mat4(1.0f), glm::vec3(0.0f, 0.0f, -Translate));glm::mat4  glm::rotate(ViewTranslate, Rotate.y, glm::vec3(-1.0f, 0.0f, 0.0f));glm::mat4  glm::rotate(ViewRotateX, Rotate.x, glm::vec3(0.0f, 1.0f, 0.0f));glm::mat4  glm::scale(glm::mat4(1.0f), glm::vec3(0.5f));glm::mat4  Projection * View * Model;glUniformMatrix4fv(LocationMVP, 1, GL_FALSE, glm::value_ptr(MVP));// Sample 3#include <glm/vec2.hpp>// glm::vec2#include <glm/packing.hpp>// glm::packUnorm2x16#include <glm/integer.hpp>// glm::uint#include <glm/gtc/type_precision.hpp>// glm::i8vec2, glm::i32vec2std::size_t const  4;// Float quad geometrystd::size_t const  VertexCount * sizeof(glm::vec2);glm::vec2 const PositionDataF32[VertexCount] =glm::vec2(-1.0f,-1.0f),glm::vec2( 1.0f,-1.0f),glm::vec2( 1.0f, 1.0f),glm::vec2(-1.0f, 1.0f)// Half-float quad geometrystd::size_t const  VertexCount * sizeof(glm::uint);glm::uint const PositionDataF16[VertexCount] =glm::uint(glm::packUnorm2x16(glm::vec2(-1.0f, -1.0f))),glm::uint(glm::packUnorm2x16(glm::vec2( 1.0f, -1.0f))),glm::uint(glm::packUnorm2x16(glm::vec2( 1.0f, 1.0f))),glm::uint(glm::packUnorm2x16(glm::vec2(-1.0f, 1.0f)))// 8 bits signed integer quad geometrystd::size_t const  VertexCount * sizeof(glm::i8vec2);glm::i8vec2 const PositionDataI8[VertexCount] =glm::i8vec2(-1,-1),glm::i8vec2( 1,-1),glm::i8vec2( 1, 1),glm::i8vec2(-1, 1)// 32 bits signed integer quad geometrystd::size_t const  VertexCount * sizeof(glm::i32vec2);glm::i32vec2 const PositionDataI32[VertexCount] =glm::i32vec2 (-1,-1),glm::i32vec2 ( 1,-1),glm::i32vec2 ( 1, 1),glm::i32vec2 (-1, 1)struct intersectionglm::vec4 position;glm::vec3 normal;// Sample 4#include <glm/vec3.hpp>// glm::vec3#include <glm/geometric.hpp>// glm::normalize, glm::dot, glm::reflect#include <glm/exponential.hpp>// glm::pow#include <glm/gtc/random.hpp>// glm::vecRand3glm::vec3 lightingintersection const& Intersection,material const& Material,light const& Light,glm::vec3 const& Viewglm::vec3 Color(0.0f);glm::vec3 LightVertor(glm::normalize(Light.position - Intersection.position +glm::vecRand3(0.0f, Light.inaccuracy));if(!shadow(Intersection.position, Light.position, LightVertor))float  glm::dot(Intersection.normal, LightVector);if(Diffuse <= 0.0f)return Color;if(Material.isDiffuse())Color += Light.color() * Material.diffuse * Diffuse;if(Material.isSpecular())glm::vec3 Reflect(glm::reflect(glm::normalize(-LightVector),glm::normalize(Intersection.normal)));float  glm::dot(Reflect, View);float  Dot > 0.0f ? Dot : 0.0f;float  glm::pow(Base, Material.exponent);Color += Material.specular * Specular;return Color;int main()glm::vec1 o(1);glm::vec2 a(1);glm::vec3 b(1);glm::vec4 c(1);glm::quat q;glm::dualquat p;glm::mat4 m(1);float  normalizeDotA(a, a);float  normalizeDotB(b, b);float  normalizeDotC(c, c);return 0;